<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <title>Professional SVG Facade Analysis</title>
  <link rel="preconnect" href="https://fonts.googleapis.com"/>
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin/>
  <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet"/>
  <style>
    body{font-family:Inter,system-ui,-apple-system,sans-serif;margin:0;padding:20px;background:linear-gradient(135deg,#667eea 0%,#764ba2 100%);min-height:100vh}
    .container{max-width:1400px;margin:0 auto;background:rgba(255,255,255,.95);border-radius:20px;padding:30px;box-shadow:0 20px 40px rgba(0,0,0,.1);backdrop-filter:blur(10px)}
    .header{text-align:center;margin-bottom:30px}
    .header h1{color:#2d3748;font-size:2.4rem;margin:0 0 10px;background:linear-gradient(45deg,#667eea,#764ba2);-webkit-background-clip:text;-webkit-text-fill-color:transparent}
    .header p{color:#718096;font-size:1.05rem;margin:0}
    .grid{display:grid;grid-template-columns:1fr 1fr;gap:30px;margin-bottom:30px}
    .panel{background:#fff;border-radius:15px;padding:25px;box-shadow:0 10px 25px rgba(0,0,0,.1);border:1px solid #e2e8f0}
    .panel h3{color:#2d3748;margin:0 0 14px;font-size:1.15rem;display:flex;align-items:center}
    .panel h3::before{content:"üè¢";margin-right:10px}
    .upload{border:2px dashed #cbd5e0;border-radius:10px;padding:30px 16px;text-align:center;transition:all .3s ease;cursor:pointer;background:#f7fafc}
    .upload:hover{border-color:#667eea;background:#edf2f7}
    .upload input{display:none}
    .svgbox{width:100%;height:320px;border:1px solid #e2e8f0;border-radius:10px;display:flex;align-items:center;justify-content:center;background:#f7fafc;margin-bottom:14px}
    .row{display:flex;gap:10px;flex-wrap:wrap;align-items:center}
    .btn{padding:10px 18px;background:linear-gradient(45deg,#667eea,#764ba2);color:#fff;border:none;border-radius:10px;cursor:pointer;font-weight:600;transition:all .2s ease}
    .btn:hover{transform:translateY(-1px);box-shadow:0 4px 12px rgba(102,126,234,.3)}
    .btn.secondary{background:#2d3748}
    .btn:disabled{background:#cbd5e0;cursor:not-allowed;transform:none;box-shadow:none}
    .meta{display:grid;grid-template-columns:repeat(2,1fr);gap:10px}
    .metric{background:#f7fafc;border:1px solid #e2e8f0;border-radius:10px;padding:12px}
    .metric .label{color:#718096;font-size:.9rem;margin-bottom:4px}
    .metric .value{color:#2d3748;font-weight:700;font-size:1.2rem}
    .status{padding:10px 15px;border-radius:8px;margin:12px 0;font-weight:500}
    .status.success{background:#c6f6d5;color:#22543d;border:1px solid #9ae6b4}
    .status.error{background:#fed7d7;color:#822727;border:1px solid #feb2b2}
    .status.warning{background:#fef3c7;color:#92400e;border:1px solid #fde68a}
    .status.info{background:#dbeafe;color:#1e40af;border:1px solid #93c5fd}

    /* Analysis container */
    .analysis-container{background:#fff;border-radius:15px;padding:0;box-shadow:0 10px 25px rgba(0,0,0,.1);border:1px solid #e2e8f0;overflow:hidden}
    .analysis-header{background:linear-gradient(135deg,#667eea,#764ba2);color:#fff;padding:20px 25px;margin:0}
    .analysis-header h3{color:#fff;margin:0;font-size:1.2rem;display:flex;align-items:center;gap:10px}
    .analysis-content{padding:25px}

    /* Metrics grid */
    .analysis-metrics{display:grid;grid-template-columns:repeat(auto-fit,minmax(180px,1fr));gap:12px;margin-bottom:20px}
    .analysis-metric{background:#f8fafc;border:1px solid #e2e8f0;border-radius:10px;padding:16px;text-align:center}
    .analysis-metric .metric-icon{font-size:24px;margin-bottom:8px}
    .analysis-metric .metric-label{color:#64748b;font-size:.85rem;margin-bottom:4px;font-weight:500}
    .analysis-metric .metric-value{color:#0f172a;font-weight:700;font-size:1.4rem}
    .analysis-metric .metric-context{color:#64748b;font-size:.75rem;margin-top:4px}

    /* Assessment + performance */
    .assessment-section{background:#fefffe;border:1px solid #e5e7eb;border-radius:12px;padding:20px;margin:16px 0}
    .assessment-header{display:flex;align-items:center;gap:12px;margin-bottom:12px}
    .assessment-icon{width:36px;height:36px;border-radius:10px;display:flex;align-items:center;justify-content:center;color:#fff;font-size:18px}
    .assessment-title{font-weight:700;color:#111827;font-size:1.05rem}
    .assessment-content{color:#374151;line-height:1.6;font-size:.95rem;white-space:normal;word-break:break-word}
    .performance-grid{display:grid;grid-template-columns:repeat(auto-fit,minmax(200px,1fr));gap:16px;margin:10px 0}
    .performance-item{background:#ffffff;border:1px solid #e5e7eb;border-radius:12px;padding:16px;transition:all .2s ease}
    .performance-item:hover{box-shadow:0 4px 12px rgba(0,0,0,.05);transform:translateY(-1px)}
    .performance-header{display:flex;justify-content:space-between;align-items:center;margin-bottom:8px}
    .performance-label{font-weight:600;color:#111827;font-size:.9rem}
    .performance-score{font-weight:700;font-size:1.1rem;padding:4px 8px;border-radius:6px}
    .score-excellent{background:#dcfce7;color:#166534}
    .score-good{background:#dbeafe;color:#1d4ed8}
    .score-fair{background:#fef3c7;color:#92400e}
    .score-poor{background:#fee2e2;color:#dc2626}
    .performance-desc{color:#6b7280;font-size:.85rem;line-height:1.4}

    /* Rec chips */
    .rec-chip{padding:8px 12px;border-radius:999px;font-weight:600;display:inline-flex;align-items:center}
    .rec-priority{display:inline-block;padding:3px 6px;border-radius:6px;font-size:.7rem;font-weight:700;margin-left:8px;border:1px solid transparent}
    .priority-high{background:#fef2f2;color:#dc2626;border-color:#fecaca}
    .priority-medium{background:#fffbeb;color:#b45309;border-color:#fed7aa}
    .priority-low{background:#f0fdf4;color:#16a34a;border-color:#bbf7d0}

    /* Code-style fallback look tidy */
    .analysis-content pre,
    .analysis-content code{
      background:#f8fafc;border:1px solid #e5e7eb;border-radius:8px;
      padding:10px;display:block;overflow:auto;font-size:.9rem
    }

    select,input[type="text"]{padding:10px 12px;border-radius:10px;border:1px solid #e2e8f0}
    .chat{background:#fff;border-radius:15px;padding:25px;box-shadow:0 10px 25px rgba(0,0,0,.1);border:1px solid #e2e8f0}
    .messages{height:380px;overflow-y:auto;border:1px solid #e2e8f0;border-radius:10px;padding:12px;background:#f7fafc;margin-bottom:12px}
    .message{margin-bottom:12px;padding:10px 12px;border-radius:10px;max-width:80%}
    .user{background:linear-gradient(45deg,#667eea,#764ba2);color:#fff;margin-left:auto}
    .bot{background:#fff;border:1px solid #e2e8f0;color:#2d3748}
    .input{display:flex;gap:10px}
    .text{flex:1;padding:12px 16px;border:1px solid #e2e8f0;border-radius:10px;font-size:16px;outline:none}
  </style>
</head>
<body>
  <div class="container">
    <div class="header">
      <h1>üè¢ Professional Facade Analysis</h1>
      <p>Upload SVG facade masks for comprehensive architectural analysis using GPT-4o</p>
    </div>

    <div class="grid">
      <div class="panel">
        <h3>Upload & Preview</h3>
        <div class="upload" onclick="document.getElementById('svgFile').click()">
          <input type="file" id="svgFile" accept=".svg" onchange="onFile(event)"/>
          <div>Click to upload SVG mask</div>
          <small style="color:#718096">Black ‚Üí windows ‚Ä¢ White/transparent ‚Üí facade</small>
        </div>
        <div class="svgbox" id="svgBox"><em style="color:#a0aec0;">Your SVG will appear here</em></div>
        <div class="row">
          <button class="btn" id="analyzeBtn" disabled onclick="performProfessionalAnalysis()">üìä Professional Analysis</button>
          <button class="btn secondary" id="downloadBtn" disabled onclick="downloadSVG()">üíæ Download</button>
        </div>
        <div class="meta" style="margin-top:10px;">
          <div class="metric"><div class="label">Window Ratio</div><div class="value" id="pctVal">‚Äî</div></div>
          <div class="metric"><div class="label">Aspect Ratio</div><div class="value" id="ratioVal">‚Äî</div></div>
        </div>
        <div id="status"></div>
      </div>

      <div class="analysis-container">
        <div class="analysis-header">
          <h3>üî¨ Professional Analysis</h3>
        </div>
        <div class="analysis-content" id="analysisContent">
          <div style="text-align:center;color:#718096;padding:40px 20px;">
            Upload an SVG facade mask to begin professional architectural analysis
          </div>
        </div>
      </div>
    </div>

    <div class="panel">
      <h3>‚öôÔ∏è AI Configuration</h3>
      <div class="row">
        <select id="provider" style="width:300px">
          <option value="openai">OpenAI</option>
        </select>
        <input type="text" id="model" value="gpt-4o" style="width:300px"/>
        <button class="btn" onclick="testConnection()" id="testBtn">Test Connection</button>
        <div id="connectionStatus" style="margin-left:8px;"></div>
      </div>
    </div>

    <div class="chat">
      <h3 style="color:#2d3748;margin-bottom:12px;">üí¨ AI-Powered SVG Editor</h3>
      <div class="messages" id="msgs">
        <div class="message bot"><strong>AI Assistant:</strong> Professional facade editing available. Try: "optimize window sizing for daylighting", "improve thermal performance", "enhance visual rhythm".</div>
      </div>
      <div class="input">
        <input class="text" id="ask" placeholder="Describe architectural modifications needed..." onkeypress="enterSend(event)"/>
        <button class="btn" onclick="send()">Send</button>
      </div>
    </div>
  </div>

  <script>
    let svgText = '';
    const ANALYSIS_RESOLUTION = 768;

    class AIClient {
      async chat(messages, temperature = 0.2) {
        const res = await fetch('/api/chat', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({
            model: "gpt-4o",
            messages,
            temperature,
            max_tokens: 4000
          })
        });
        if (!res.ok) throw new Error(await res.text());
        const data = await res.json();
        return data.choices?.[0]?.message?.content || '';
      }
    }
    const ai = new AIClient();

    // =========================
    // Upload + Rendering (FIXED)
    // =========================
    async function onFile(event) {
      const file = event.target.files[0];
      if (!file) { showToast('No file selected', 'error'); return; }

      const looksSvg = file.type === 'image/svg+xml' || file.type === 'image/svg' || /\.svg$/i.test(file.name);
      if (!looksSvg) { showToast('Please upload a valid .svg file', 'error'); return; }

      const reader = new FileReader();
      reader.onload = async (e) => {
        try {
          const normalized = await normalizeSvgRoot(e.target.result);
          svgText = normalized.svgText;
          renderSVG(svgText);
          enableControls(true);

          const metrics = await analyzeFacadeMetrics(svgText);
          document.getElementById('pctVal').textContent = metrics.windowToWallRatio.toFixed(1) + '%';
          document.getElementById('ratioVal').textContent = metrics.aspectRatio.toFixed(2) + ':1';
          showToast('SVG uploaded successfully', 'success');
        } catch (error) {
          console.error(error);
          showToast('SVG uploaded but failed to parse/normalize', 'warning');
        }
      };
      reader.readAsText(file);
    }

    function renderSVG(svg) {
      const container = document.getElementById('svgBox');
      container.innerHTML = '';

      const parser = new DOMParser();
      const doc = parser.parseFromString(svg, 'image/svg+xml');

      const parseErr = doc.querySelector('parsererror');
      if (parseErr) {
        showToast('Invalid SVG markup', 'error');
        container.innerHTML = '<em style="color:#a0aec0;">Invalid SVG</em>';
        return;
      }

      const svgEl = doc.documentElement;
      svgEl.style.width = '100%';
      svgEl.style.height = '100%';
      svgEl.style.maxHeight = '300px';
      svgEl.setAttribute('preserveAspectRatio', 'xMidYMid meet');

      container.appendChild(svgEl);
    }

    async function normalizeSvgRoot(rawSvg) {
      const parser = new DOMParser();
      const doc = parser.parseFromString(rawSvg, 'image/svg+xml');
      const parseErr = doc.querySelector('parsererror');
      if (parseErr) throw new Error('SVG parse error');

      const svg = doc.querySelector('svg');
      if (!svg) throw new Error('No <svg> root found');

      if (!svg.getAttribute('xmlns')) svg.setAttribute('xmlns', 'http://www.w3.org/2000/svg');
      if (!svg.getAttribute('xmlns:xlink')) svg.setAttribute('xmlns:xlink', 'http://www.w3.org/1999/xlink');

      const wAttr = svg.getAttribute('width');
      const hAttr = svg.getAttribute('height');
      let width = parseFloat(wAttr || '') || 1000;
      let height = parseFloat(hAttr || '') || 1000;

      const vb = svg.getAttribute('viewBox');
      if (!vb) {
        svg.setAttribute('viewBox', `0 0 ${width} ${height}`);
      } else {
        const parts = vb.split(/[\s,]+/).map(Number);
        if (parts.length === 4) {
          width = parts[2] || width;
          height = parts[3] || height;
        }
      }
      svg.removeAttribute('width');
      svg.removeAttribute('height');

      const svgText = new XMLSerializer().serializeToString(doc);
      return { svgText, w: width, h: height };
    }

    async function normalizeSvgSize(svgText) { return normalizeSvgRoot(svgText); }

    function sanitizeForCanvas(svgText) {
      const parser = new DOMParser();
      const doc = parser.parseFromString(svgText, 'image/svg+xml');
      const images = doc.querySelectorAll('image, img');

      images.forEach((img) => {
        const href = img.getAttribute('href') || img.getAttributeNS('http://www.w3.org/1999/xlink', 'href');
        if (href && /^https?:\/\//i.test(href)) img.parentNode.removeChild(img);
      });

      return new XMLSerializer().serializeToString(doc);
    }

    // =========================
    // Professional Analysis (compact)
    // =========================
    async function performProfessionalAnalysis() {
      if (!svgText) return;

      const analysisContent = document.getElementById('analysisContent');
      analysisContent.innerHTML = '<div style="text-align:center;padding:40px;"><span class="loading-spinner"></span> <span style="margin-left:10px;">Performing concise analysis...</span></div>';

      try {
        const metrics = await analyzeFacadeMetrics(svgText);
        const analysis = await getAIProfessionalAnalysis(metrics, svgText);
        renderProfessionalAnalysis(metrics, analysis);
      } catch (error) {
        console.error('Analysis failed:', error);
        analysisContent.innerHTML = `
          <div class="status error">
            Analysis failed: ${error.message}. Please check your AI connection and try again.
          </div>`;
      }
    }

    async function getAIProfessionalAnalysis(metrics, svg) {
      const systemPrompt = `You are a senior facade consultant.
Return ONLY compact JSON (no markdown) with fields:
{
  "summary": ["‚Ä¢ one-line finding", "‚Ä¢ one-line finding", "‚Ä¢ one-line finding"],
  "performance": { "energy": 0-100, "daylighting": 0-100, "thermal": 0-100, "visual": 0-100 },
  "recommendations": [
    { "id":"slug", "title":"Short action label", "rationale":"1 sentence why", "priority":"high|medium|low", "action_prompt":"Plain-English edit request the SVG editor can apply" }
  ]
}
Rules: Be concise. Avoid repeating WWR/areas already shown in UI. Keep 3‚Äì6 recommendations.`;
      const userPrompt = `Metrics:
- WWR: ${metrics.windowToWallRatio.toFixed(1)}%
- Aspect Ratio: ${metrics.aspectRatio.toFixed(2)}:1
- Window Area: ${Math.round(metrics.windowArea)}
Return the JSON now.`;

      const raw = await ai.chat([
        { role: 'system', content: systemPrompt },
        { role: 'user', content: userPrompt }
      ], 0.2);

      return coerceAnalysisResponse(raw);
    }

    function coerceAnalysisResponse(text) {
      let cleaned = text.trim().replace(/^```(?:json|js|javascript)?\s*/i, '').replace(/```$/i, '').trim();
      let obj = tryParseJSON(cleaned);
      if (!obj) {
        const m = cleaned.match(/\{[\s\S]*\}$/m);
        if (m) obj = tryParseJSON(m[0]);
      }
      if (!obj || typeof obj !== 'object') {
        return {
          summary: ["Analysis available but response was unstructured."],
          performance: { energy: 75, daylighting: 80, thermal: 70, visual: 85 },
          recommendations: [
            { id: "review", title: "Review analysis", rationale: "Response not structured", priority: "medium", action_prompt: "No change" }
          ]
        };
      }
      return normalizeCompact(obj);
    }
    function tryParseJSON(s){ try { return JSON.parse(s); } catch { return null; } }
    function normalizeCompact(a) {
      const summary = Array.isArray(a.summary) ? a.summary.filter(Boolean).slice(0,3) : [];
      const perf = a.performance && typeof a.performance === 'object' ? a.performance : {};
      let recs = Array.isArray(a.recommendations) ? a.recommendations : [];
      const seen = new Set();
      recs = recs.filter(r => {
        const k = (r.title || '').trim().toLowerCase();
        if (!k || seen.has(k)) return false;
        seen.add(k);
        return true;
      }).slice(0,6).map((r,i)=>({
        id: r.id || `rec-${i+1}`,
        title: r.title || `Recommendation ${i+1}`,
        rationale: r.rationale || '',
        priority: (r.priority || 'medium').toLowerCase(),
        action_prompt: r.action_prompt || r.title || 'Improve facade.'
      }));
      return { summary, performance: perf, recommendations: recs };
    }

    function renderProfessionalAnalysis(metrics, analysis) {
      const container = document.getElementById('analysisContent');
      const perf = analysis.performance || {};
      const recs = Array.isArray(analysis.recommendations) ? analysis.recommendations : [];
      const summary = Array.isArray(analysis.summary) ? analysis.summary : [];

      container.innerHTML = `
        <!-- Key Metrics -->
        <div class="analysis-metrics">
          <div class="analysis-metric">
            <div class="metric-icon">üî¢</div>
            <div class="metric-label">WWR</div>
            <div class="metric-value">${metrics.windowToWallRatio.toFixed(1)}%</div>
            <div class="metric-context">${getWWRAssessment(metrics.windowToWallRatio)}</div>
          </div>
          <div class="analysis-metric">
            <div class="metric-icon">üìè</div>
            <div class="metric-label">Aspect Ratio</div>
            <div class="metric-value">${metrics.aspectRatio.toFixed(2)}:1</div>
            <div class="metric-context">${getAspectAssessment(metrics.aspectRatio)}</div>
          </div>
          <div class="analysis-metric">
            <div class="metric-icon">üèóÔ∏è</div>
            <div class="metric-label">Facade Area</div>
            <div class="metric-value">${Math.round(metrics.totalArea).toLocaleString()}</div>
            <div class="metric-context">units¬≤</div>
          </div>
          <div class="analysis-metric">
            <div class="metric-icon">ü™ü</div>
            <div class="metric-label">Window Area</div>
            <div class="metric-value">${Math.round(metrics.windowArea).toLocaleString()}</div>
            <div class="metric-context">units¬≤</div>
          </div>
        </div>

        <!-- Summary -->
        <div class="assessment-section">
          <div class="assessment-header">
            <div class="assessment-icon" style="background:linear-gradient(45deg,#3b82f6,#1d4ed8)">üéØ</div>
            <div class="assessment-title">Executive Summary</div>
          </div>
          <div class="assessment-content">
            ${summary.length ? `<ul style="margin:0;padding-left:18px;color:#374151;">${summary.map(s=>`<li>${escapeHTML(s)}</li>`).join('')}</ul>` : '<p>Summary not available.</p>'}
          </div>
        </div>

        <!-- Compact performance -->
        <div class="assessment-section">
          <div class="assessment-header">
            <div class="assessment-icon" style="background:linear-gradient(45deg,#10b981,#059669)">üìä</div>
            <div class="assessment-title">Performance (0‚Äì100)</div>
          </div>
          <div class="performance-grid">
            ${Object.entries(perf).map(([k,v])=>`
              <div class="performance-item">
                <div class="performance-header">
                  <div class="performance-label">${capitalizeFirst(k)}</div>
                  <div class="performance-score ${getScoreClass(v)}">${v||0}/100</div>
                </div>
                <div class="performance-desc">${getPerformanceDescription(k, v||0)}</div>
              </div>
            `).join('')}
          </div>
        </div>

        <!-- Recommendations -->
        ${recs.length ? `
        <div class="assessment-section">
          <div class="assessment-header">
            <div class="assessment-icon" style="background:linear-gradient(45deg,#8b5cf6,#7c3aed)">üí°</div>
            <div class="assessment-title">Recommendations</div>
          </div>

          <div class="performance-desc" style="margin-bottom:8px;color:#6b7280;">
            Click a chip to apply via the AI editor. You can tweak the prompt in the chat afterward.
          </div>

          <div class="row" style="gap:8px;flex-wrap:wrap;">
            ${recs.map(r => `
              <button class="btn rec-chip" onclick='applyRecommendation(${JSON.stringify(r)})'>
                ${escapeHTML(r.title)} ${priorityBadge(r.priority)}
              </button>
            `).join('')}
          </div>

          <div style="margin-top:12px;">
            ${recs.map(r => `
              <div class="performance-item" style="margin-bottom:10px;">
                <div class="performance-header">
                  <div class="performance-label">${escapeHTML(r.title)}</div>
                  <div class="rec-priority priority-${r.priority}">${r.priority.toUpperCase()}</div>
                </div>
                <div class="performance-desc">${escapeHTML(r.rationale)}</div>
                <div class="performance-desc" style="margin-top:6px;"><strong>Prompt:</strong> ${escapeHTML(r.action_prompt)}</div>
              </div>
            `).join('')}
          </div>
        </div>` : '' }
      `;
    }

    function priorityBadge(p){
      const map = {high:'üî•', medium:'‚öñÔ∏è', low:'üåø'};
      return `<span class="rec-priority priority-${p || 'medium'}">${(p||'medium').toUpperCase()} ${map[p]||''}</span>`;
    }

    // =========================
    // Metrics & low-level analyzers
    // =========================
    async function analyzeFacadeMetrics(svg) {
      const { svgText: normalized, w: width, h: height } = await normalizeSvgSize(svg);
      const { pct: wwr, resW, resH } = await calculateWindowRatio(normalized, ANALYSIS_RESOLUTION);
      const aspectRatio = width / height;
      const totalArea = width * height;
      const windowArea = (wwr / 100) * totalArea;
      const distribution = await analyzeWindowDistribution(normalized);
      return {
        windowToWallRatio: wwr,
        aspectRatio,
        facadeWidth: width,
        facadeHeight: height,
        totalArea,
        windowArea,
        analysisResolution: `${resW}√ó${resH}`,
        distribution
      };
    }

    async function calculateWindowRatio(svg, resolution) {
      const { svgText: fixed, w: vw, h: vh } = await normalizeSvgSize(svg);

      let cw, ch;
      if (vw >= vh) { cw = resolution; ch = Math.max(1, Math.round(resolution * (vh / vw))); }
      else { ch = resolution; cw = Math.max(1, Math.round(resolution * (vw / vh))); }

      const safeSvg = sanitizeForCanvas(fixed);
      const img = await svgToImage(safeSvg);

      const canvas = document.createElement('canvas');
      canvas.width = cw; canvas.height = ch;
      const ctx = canvas.getContext('2d');

      ctx.fillStyle = '#ffffff';
      ctx.fillRect(0, 0, cw, ch);
      ctx.drawImage(img, 0, 0, cw, ch);

      const imageData = ctx.getImageData(0, 0, cw, ch).data;
      let blackPixels = 0, totalPixels = 0;

      for (let i = 0; i < imageData.length; i += 4) {
        const r = imageData[i], g = imageData[i + 1], b = imageData[i + 2], a = imageData[i + 3];
        if (a < 10) continue;
        totalPixels++;
        const luminance = 0.2126 * r + 0.7152 * g + 0.0722 * b;
        if (luminance < 40) blackPixels++;
      }
      const percentage = totalPixels > 0 ? (blackPixels / totalPixels) * 100 : 0;
      return { pct: percentage, resW: cw, resH: ch, vw, vh };
    }

    async function analyzeWindowDistribution(svg) {
      return { horizontal: "regular", vertical: "regular", clustering: "distributed" };
    }

    function svgToImage(svgText) {
      return new Promise((resolve, reject) => {
        const img = new Image();
        const blob = new Blob([svgText], { type: 'image/svg+xml' });
        const url = URL.createObjectURL(blob);
        img.onload = () => { URL.revokeObjectURL(url); resolve(img); };
        img.onerror = () => { URL.revokeObjectURL(url); reject(new Error('Failed to load SVG as image')); };
        img.src = url;
      });
    }

    // =========================
    // Helpers for display
    // =========================
    function getWWRAssessment(wwr) {
      if (wwr < 15) return "Low glazing";
      if (wwr < 30) return "Conservative";
      if (wwr < 45) return "Balanced";
      if (wwr < 60) return "High glazing";
      return "Very high";
    }
    function getAspectAssessment(ratio) {
      if (ratio < 0.5) return "Very tall";
      if (ratio < 0.8) return "Tall";
      if (ratio < 1.2) return "Square";
      if (ratio < 2) return "Wide";
      return "Very wide";
    }
    function getScoreClass(score) {
      if (score >= 85) return "score-excellent";
      if (score >= 70) return "score-good";
      if (score >= 55) return "score-fair";
      return "score-poor";
    }
    function getPerformanceDescription(category, score) {
      const descriptions = {
        energy: score >= 70 ? "Good thermal performance expected" : "Energy efficiency could be improved",
        daylighting: score >= 70 ? "Adequate natural light penetration" : "Consider optimizing window placement",
        thermal: score >= 70 ? "Balanced solar heat gain" : "Review shading and glazing strategies",
        visual: score >= 70 ? "Good architectural rhythm and proportions" : "Consider facade composition improvements"
      };
      return descriptions[category] || "Performance analysis available";
    }
    function capitalizeFirst(str) { return str ? str.charAt(0).toUpperCase() + str.slice(1) : ''; }
    function escapeHTML(s) {
      return String(s).replace(/&/g,'&amp;').replace(/</g,'&lt;').replace(/>/g,'&gt;').replace(/"/g,'&quot;').replace(/'/g,'&#39;');
    }

    // =========================
    // Chat + Rec application
    // =========================
    function addMessage(text, sender = 'bot') {
      const messages = document.getElementById('msgs');
      const message = document.createElement('div');
      message.className = `message ${sender}`;
      message.innerHTML = `<strong>${sender === 'user' ? 'You' : 'AI Assistant'}:</strong> ${escapeHTML(text)}`;
      messages.appendChild(message);
      messages.scrollTop = messages.scrollHeight;
    }

    async function send() {
      const input = document.getElementById('ask');
      const message = input.value.trim();
      if (!message) return;

      addMessage(message, 'user');
      input.value = '';

      if (!svgText) {
        try {
          const response = await ai.chat([{ role: 'user', content: message }]);
          addMessage(response);
        } catch (error) {
          addMessage('Error contacting AI. Please check your connection.', 'bot');
        }
        return;
      }

      try {
        const editPrompt = `You are an expert SVG facade editor. The user wants to: "${message}"

Current SVG:
${svgText}

Return ONLY the modified SVG code. Preserve viewBox and dimensions. Black shapes are windows, white/transparent is facade material.`;

        const response = await ai.chat(
          [
            { role: 'system', content: 'Return only valid SVG code with no explanations.' },
            { role: 'user', content: editPrompt }
          ],
          0.1
        );

        const modifiedSVG = extractSVGFromResponse(response);
        if (modifiedSVG && modifiedSVG !== svgText) {
          const normalized = await normalizeSvgRoot(modifiedSVG);
          svgText = normalized.svgText;
          renderSVG(svgText);

          const metrics = await analyzeFacadeMetrics(svgText);
          document.getElementById('pctVal').textContent = metrics.windowToWallRatio.toFixed(1) + '%';
          document.getElementById('ratioVal').textContent = metrics.aspectRatio.toFixed(2) + ':1';

          addMessage(`Applied successfully! New WWR: ${metrics.windowToWallRatio.toFixed(1)}%`);
        } else {
          addMessage('Could not apply the requested modification. Please try tweaking the prompt.', 'bot');
        }
      } catch (error) {
        console.error('Edit error:', error);
        addMessage('Error processing your request. Please try again or check your AI connection.', 'bot');
      }
    }

    async function applyRecommendation(rec) {
      if (!svgText) { addMessage('Upload an SVG first.', 'bot'); return; }
      const message = rec.action_prompt || rec.title || 'Improve the facade.';
      addMessage(`Apply: ${message}`, 'user');

      try {
        const editPrompt = `You are an expert SVG facade editor. The user wants to: "${message}"

Current SVG:
${svgText}

Return ONLY the modified SVG code. Preserve viewBox and dimensions. Black shapes are windows, white/transparent is facade material.`;

        const response = await ai.chat(
          [
            { role: 'system', content: 'Return only valid SVG code with no explanations.' },
            { role: 'user', content: editPrompt }
          ],
          0.1
        );

        const modifiedSVG = extractSVGFromResponse(response);
        if (modifiedSVG && modifiedSVG !== svgText) {
          const normalized = await normalizeSvgRoot(modifiedSVG);
          svgText = normalized.svgText;
          renderSVG(svgText);

          const metrics = await analyzeFacadeMetrics(svgText);
          document.getElementById('pctVal').textContent = metrics.windowToWallRatio.toFixed(1) + '%';
          document.getElementById('ratioVal').textContent = metrics.aspectRatio.toFixed(2) + ':1';

          addMessage(`Applied "${rec.title}". New WWR: ${metrics.windowToWallRatio.toFixed(1)}%`);
        } else {
          addMessage('Could not apply this recommendation. Try tweaking the prompt in the chat.', 'bot');
        }
      } catch (err) {
        console.error(err);
        addMessage('Error applying recommendation. Please try again.', 'bot');
      }
    }

    function extractSVGFromResponse(text) {
      text = text.replace(/```(?:svg)?\s*([\s\S]*?)\s*```/gi, (_, content) => content.trim());
      text = text.replace(/^\s*<\?xml[\s\S]*?\?>/i, '').replace(/<!DOCTYPE[\s\S]*?>/i, '').trim();
      const svgMatch = text.match(/<svg[\s\S]*?<\/svg>/i);
      return svgMatch ? svgMatch[0] : null;
    }

    function enterSend(event) { if (event.key === 'Enter') send(); }

    // =========================
    // UI utilities
    // =========================
    function enableControls(enabled) {
      document.getElementById('analyzeBtn').disabled = !enabled;
      document.getElementById('downloadBtn').disabled = !enabled;
    }

    function showToast(message, type = 'success') {
      const toast = document.createElement('div');
      toast.className = `status ${type}`;
      toast.textContent = message;
      toast.style.cssText = 'position:fixed;top:20px;right:20px;z-index:1000;';
      document.body.appendChild(toast);
      setTimeout(() => toast.remove(), 3000);
    }

    async function testConnection() {
      const status = document.getElementById('connectionStatus');
      status.innerHTML = '<span class="loading-spinner"></span> Testing...';
      try { await ai.chat([{ role: 'user', content: 'Test connection' }]); status.innerHTML = '<span style="color:#059669;">‚úÖ Connected</span>'; }
      catch { status.innerHTML = '<span style="color:#dc2626;">‚ùå Failed</span>'; }
      setTimeout(() => { status.innerHTML = ''; }, 3000);
    }

    function downloadSVG() {
      if (!svgText) return;
      const blob = new Blob([svgText], { type: 'image/svg+xml' });
      const url = URL.createObjectURL(blob);
      const a = document.createElement('a');
      a.href = url;
      a.download = 'facade_analysis.svg';
      a.click();
      URL.revokeObjectURL(url);
      showToast('SVG downloaded', 'success');
    }
  </script>
</body>
</html>
